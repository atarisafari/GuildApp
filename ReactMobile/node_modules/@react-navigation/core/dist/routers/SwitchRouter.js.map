{"version":3,"sources":["../../src/routers/SwitchRouter.js"],"names":["invariant","getScreenForRouteName","createConfigGetter","NavigationActions","StackActions","validateRouteConfigMap","createPathParser","defaultActionCreators","childrenUpdateWithoutSwitchingIndex","actionType","SET_PARAMS","COMPLETE_TRANSITION","includes","routeConfigs","config","order","Object","keys","getCustomActionCreators","initialRouteParams","initialRouteName","backBehavior","resetOnBlur","hasOwnProperty","initialRouteIndex","indexOf","Error","map","n","join","childRouters","forEach","routeName","screen","router","getParamsForRoute","params","routeConfig","getPathAndParamsForRoute","getActionForPathAndParams","resetChildRoute","initialParams","undefined","childRouter","childAction","init","getStateForAction","key","getNextState","action","prevState","possibleNextState","updateNextStateHistory","nextState","nextRouteKeyHistory","routeKeyHistory","type","NAVIGATE","keyToAdd","routes","index","filter","k","push","BACK","pop","prevRouteName","nextRoutes","getInitialState","initialState","isTransitioning","initialKey","getActionCreators","route","stateKey","inputState","state","activeChildIndex","INIT","activeChildLastState","activeChildRouter","activeChildState","isBackEligible","Math","max","length","routeKey","didNavigate","find","childId","i","childState","newChildState","childStateUpdate","lastRoute","getComponentForState","getComponentForRouteName","getPathAndParamsForState","path","getScreenOptions","defaultNavigationOptions"],"mappings":"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","sourcesContent":["import invariant from '../utils/invariant';\nimport getScreenForRouteName from './getScreenForRouteName';\nimport createConfigGetter from './createConfigGetter';\n\nimport NavigationActions from '../NavigationActions';\nimport StackActions from './StackActions';\nimport validateRouteConfigMap from './validateRouteConfigMap';\nimport { createPathParser } from './pathUtils';\n\nconst defaultActionCreators = () => ({});\n\nfunction childrenUpdateWithoutSwitchingIndex(actionType) {\n  return [\n    NavigationActions.SET_PARAMS,\n    // Todo: make SwitchRouter not depend on StackActions..\n    StackActions.COMPLETE_TRANSITION,\n  ].includes(actionType);\n}\n\nexport default (routeConfigs, config = {}) => {\n  // Fail fast on invalid route definitions\n  validateRouteConfigMap(routeConfigs);\n\n  const order = config.order || Object.keys(routeConfigs);\n\n  const getCustomActionCreators =\n    config.getCustomActionCreators || defaultActionCreators;\n\n  const initialRouteParams = config.initialRouteParams;\n  const initialRouteName = config.initialRouteName || order[0];\n  const backBehavior = config.backBehavior || 'none';\n  const resetOnBlur = config.hasOwnProperty('resetOnBlur')\n    ? config.resetOnBlur\n    : true;\n\n  const initialRouteIndex = order.indexOf(initialRouteName);\n  if (initialRouteIndex === -1) {\n    throw new Error(\n      `Invalid initialRouteName '${initialRouteName}'.` +\n        `Should be one of ${order.map(n => `\"${n}\"`).join(', ')}`\n    );\n  }\n\n  const childRouters = {};\n  order.forEach(routeName => {\n    childRouters[routeName] = null;\n    const screen = getScreenForRouteName(routeConfigs, routeName);\n    if (screen.router) {\n      childRouters[routeName] = screen.router;\n    }\n  });\n\n  function getParamsForRoute(routeName, params) {\n    let routeConfig = routeConfigs[routeName];\n    if (routeConfig && routeConfig.params) {\n      return { ...routeConfig.params, ...params };\n    } else {\n      return params;\n    }\n  }\n\n  const {\n    getPathAndParamsForRoute,\n    getActionForPathAndParams,\n  } = createPathParser(childRouters, routeConfigs, config);\n\n  function resetChildRoute(routeName) {\n    let initialParams =\n      routeName === initialRouteName ? initialRouteParams : undefined;\n    // note(brentvatne): merging initialRouteParams *on top* of default params\n    // on the route seems incorrect but it's consistent with existing behavior\n    // in stackrouter\n    let params = getParamsForRoute(routeName, initialParams);\n    const childRouter = childRouters[routeName];\n    if (childRouter) {\n      const childAction = NavigationActions.init();\n      return {\n        ...childRouter.getStateForAction(childAction),\n        key: routeName,\n        routeName,\n        params,\n      };\n    }\n    return {\n      key: routeName,\n      routeName,\n      params,\n    };\n  }\n\n  function getNextState(action, prevState, possibleNextState) {\n    function updateNextStateHistory(nextState) {\n      if (backBehavior !== 'history') {\n        return nextState;\n      }\n      let nextRouteKeyHistory = prevState.routeKeyHistory;\n      if (action.type === NavigationActions.NAVIGATE) {\n        nextRouteKeyHistory = [...prevState.routeKeyHistory]; // copy\n        const keyToAdd = nextState.routes[nextState.index].key;\n        nextRouteKeyHistory = nextRouteKeyHistory.filter(k => k !== keyToAdd); // dedup\n        nextRouteKeyHistory.push(keyToAdd);\n      } else if (action.type === NavigationActions.BACK) {\n        nextRouteKeyHistory = [...prevState.routeKeyHistory]; // copy\n        nextRouteKeyHistory.pop();\n      }\n      return {\n        ...nextState,\n        routeKeyHistory: nextRouteKeyHistory,\n      };\n    }\n\n    let nextState = possibleNextState;\n    if (\n      prevState &&\n      prevState.index !== possibleNextState.index &&\n      resetOnBlur\n    ) {\n      const prevRouteName = prevState.routes[prevState.index].routeName;\n      const nextRoutes = [...possibleNextState.routes];\n      nextRoutes[prevState.index] = resetChildRoute(prevRouteName);\n      nextState = {\n        ...possibleNextState,\n        routes: nextRoutes,\n      };\n    }\n    return updateNextStateHistory(nextState);\n  }\n\n  function getInitialState() {\n    const routes = order.map(resetChildRoute);\n    const initialState = {\n      routes,\n      index: initialRouteIndex,\n      isTransitioning: false,\n    };\n    if (backBehavior === 'history') {\n      const initialKey = routes[initialRouteIndex].key;\n      initialState['routeKeyHistory'] = [initialKey];\n    }\n    return initialState;\n  }\n\n  return {\n    childRouters,\n\n    getActionCreators(route, stateKey) {\n      return getCustomActionCreators(route, stateKey);\n    },\n\n    getStateForAction(action, inputState) {\n      let prevState = inputState ? { ...inputState } : inputState;\n      let state = inputState || getInitialState();\n      let activeChildIndex = state.index;\n\n      if (action.type === NavigationActions.INIT) {\n        // NOTE(brentvatne): this seems weird... why are we merging these\n        // params into child routes?\n        // ---------------------------------------------------------------\n        // Merge any params from the action into all the child routes\n        const { params } = action;\n        if (params) {\n          state.routes = state.routes.map(route => ({\n            ...route,\n            params: {\n              ...route.params,\n              ...params,\n              ...(route.routeName === initialRouteName\n                ? initialRouteParams\n                : null),\n            },\n          }));\n        }\n      }\n\n      // Let the current child handle it\n      const activeChildLastState = state.routes[state.index];\n      const activeChildRouter = childRouters[order[state.index]];\n      if (activeChildRouter) {\n        const activeChildState = activeChildRouter.getStateForAction(\n          action,\n          activeChildLastState\n        );\n        if (!activeChildState && inputState) {\n          return null;\n        }\n        if (activeChildState && activeChildState !== activeChildLastState) {\n          const routes = [...state.routes];\n          routes[state.index] = activeChildState;\n          return getNextState(action, prevState, {\n            ...state,\n            routes,\n          });\n        }\n      }\n\n      // Handle tab changing. Do this after letting the current tab try to\n      // handle the action, to allow inner children to change first\n      const isBackEligible =\n        action.key == null || action.key === activeChildLastState.key;\n      if (action.type === NavigationActions.BACK) {\n        if (isBackEligible && backBehavior === 'initialRoute') {\n          activeChildIndex = initialRouteIndex;\n        } else if (isBackEligible && backBehavior === 'order') {\n          activeChildIndex = Math.max(0, activeChildIndex - 1);\n        }\n        // The history contains current route, so we can only go back\n        // if there is more than one item in the history\n        else if (\n          isBackEligible &&\n          backBehavior === 'history' &&\n          state.routeKeyHistory.length > 1\n        ) {\n          const routeKey =\n            state.routeKeyHistory[state.routeKeyHistory.length - 2];\n          activeChildIndex = order.indexOf(routeKey);\n        } else {\n          return state;\n        }\n      }\n\n      let didNavigate = false;\n      if (action.type === NavigationActions.NAVIGATE) {\n        didNavigate = !!order.find((childId, i) => {\n          if (childId === action.routeName) {\n            activeChildIndex = i;\n            return true;\n          }\n          return false;\n        });\n        if (didNavigate) {\n          const childState = state.routes[activeChildIndex];\n          const childRouter = childRouters[action.routeName];\n          let newChildState = childState;\n\n          if (action.action && childRouter) {\n            const childStateUpdate = childRouter.getStateForAction(\n              action.action,\n              childState\n            );\n            if (childStateUpdate) {\n              newChildState = childStateUpdate;\n            }\n          }\n\n          if (action.params) {\n            newChildState = {\n              ...newChildState,\n              params: {\n                ...(newChildState.params || {}),\n                ...action.params,\n              },\n            };\n          }\n\n          if (newChildState !== childState) {\n            const routes = [...state.routes];\n            routes[activeChildIndex] = newChildState;\n            const nextState = {\n              ...state,\n              routes,\n              index: activeChildIndex,\n            };\n            return getNextState(action, prevState, nextState);\n          } else if (\n            newChildState === childState &&\n            state.index === activeChildIndex &&\n            prevState\n          ) {\n            return null;\n          }\n        }\n      }\n\n      if (action.type === NavigationActions.SET_PARAMS) {\n        const key = action.key;\n        const lastRoute = state.routes.find(route => route.key === key);\n        if (lastRoute) {\n          const params = {\n            ...lastRoute.params,\n            ...action.params,\n          };\n          const routes = [...state.routes];\n          routes[state.routes.indexOf(lastRoute)] = {\n            ...lastRoute,\n            params,\n          };\n          return getNextState(action, prevState, {\n            ...state,\n            routes,\n          });\n        }\n      }\n\n      if (activeChildIndex !== state.index) {\n        return getNextState(action, prevState, {\n          ...state,\n          index: activeChildIndex,\n        });\n      } else if (didNavigate && !inputState) {\n        return state;\n      } else if (didNavigate) {\n        return { ...state };\n      }\n\n      // Let other children handle it and switch to the first child that returns a new state\n      let index = state.index;\n      let routes = state.routes;\n      order.find((childId, i) => {\n        const childRouter = childRouters[childId];\n        if (i === index) {\n          return false;\n        }\n        let childState = routes[i];\n        if (childRouter) {\n          childState = childRouter.getStateForAction(action, childState);\n        }\n        if (!childState) {\n          index = i;\n          return true;\n        }\n        if (childState !== routes[i]) {\n          routes = [...routes];\n          routes[i] = childState;\n          index = i;\n          return true;\n        }\n        return false;\n      });\n\n      // Nested routers can be updated after switching children with actions such as SET_PARAMS\n      // and COMPLETE_TRANSITION.\n      // NOTE: This may be problematic with custom routers because we whitelist the actions\n      // that can be handled by child routers without automatically changing index.\n      if (childrenUpdateWithoutSwitchingIndex(action.type)) {\n        index = state.index;\n      }\n\n      if (index !== state.index || routes !== state.routes) {\n        return getNextState(action, prevState, {\n          ...state,\n          index,\n          routes,\n        });\n      }\n      return state;\n    },\n\n    getComponentForState(state) {\n      const routeName = state.routes[state.index].routeName;\n      invariant(\n        routeName,\n        `There is no route defined for index ${state.index}. Check that\n        that you passed in a navigation state with a valid tab/screen index.`\n      );\n      const childRouter = childRouters[routeName];\n      if (childRouter) {\n        return childRouter.getComponentForState(state.routes[state.index]);\n      }\n      return getScreenForRouteName(routeConfigs, routeName);\n    },\n\n    getComponentForRouteName(routeName) {\n      return getScreenForRouteName(routeConfigs, routeName);\n    },\n\n    getPathAndParamsForState(state) {\n      const route = state.routes[state.index];\n      return getPathAndParamsForRoute(route);\n    },\n\n    getActionForPathAndParams(path, params) {\n      return getActionForPathAndParams(path, params);\n    },\n\n    getScreenOptions: createConfigGetter(\n      routeConfigs,\n      config.defaultNavigationOptions\n    ),\n  };\n};\n"],"file":"SwitchRouter.js"}