{"version":3,"sources":["../../src/routers/StackRouter.js"],"names":["NavigationActions","StackActions","createConfigGetter","getScreenForRouteName","StateUtils","validateRouteConfigMap","invariant","generateKey","createPathParser","behavesLikePushAction","action","type","NAVIGATE","PUSH","defaultActionCreators","isResetToRootStack","RESET","key","routeConfigs","stackConfig","childRouters","routeNames","Object","keys","forEach","routeName","screen","router","initialRouteParams","getCustomActionCreators","initialRouteName","initialChildRouter","getInitialState","route","childRouter","undefined","childState","childAction","init","params","getStateForAction","isTransitioning","index","routes","navigate","initialRouteKey","getParamsForRouteAndAction","routeConfig","getPathAndParamsForRoute","getActionForPathAndParams","getComponentForState","state","activeChildRoute","getComponentForRouteName","getActionCreators","navStateKey","pop","n","popToTop","push","replace","replaceWith","newKey","reset","actions","length","dismiss","back","activeChildRouter","replaceAt","SET_PARAMS","childRoute","slice","reverse","nextRouteState","newState","replaceAndPrune","immediate","lastRouteIndex","findIndex","r","childRouterNames","i","childRouterName","initChildRoute","navigatedChildRoute","routeToPush","POP_TO_TOP","REPLACE","routeIndex","COMPLETE_TRANSITION","toChildKey","lastRoute","find","indexOf","newStackActions","map","newStackAction","BACK","POP","backRouteIndex","Math","max","backRoute","keyIndex","includes","getPathAndParamsForState","path","getScreenOptions","defaultNavigationOptions"],"mappings":"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","sourcesContent":["import NavigationActions from '../NavigationActions';\nimport StackActions from './StackActions';\nimport createConfigGetter from './createConfigGetter';\nimport getScreenForRouteName from './getScreenForRouteName';\nimport StateUtils from '../StateUtils';\nimport validateRouteConfigMap from './validateRouteConfigMap';\nimport invariant from '../utils/invariant';\nimport { generateKey } from './KeyGenerator';\nimport { createPathParser } from './pathUtils';\n\nfunction behavesLikePushAction(action) {\n  return (\n    action.type === NavigationActions.NAVIGATE ||\n    action.type === StackActions.PUSH\n  );\n}\n\nconst defaultActionCreators = () => ({});\n\nfunction isResetToRootStack(action) {\n  return action.type === StackActions.RESET && action.key === null;\n}\n\nexport default (routeConfigs, stackConfig = {}) => {\n  // Fail fast on invalid route definitions\n  validateRouteConfigMap(routeConfigs);\n\n  const childRouters = {};\n  const routeNames = Object.keys(routeConfigs);\n\n  // Loop through routes and find child routers\n  routeNames.forEach(routeName => {\n    const screen = getScreenForRouteName(routeConfigs, routeName);\n    if (screen && screen.router) {\n      // If it has a router it's a navigator.\n      childRouters[routeName] = screen.router;\n    } else {\n      // If it doesn't have router it's an ordinary React component.\n      childRouters[routeName] = null;\n    }\n  });\n\n  const { initialRouteParams } = stackConfig;\n  const getCustomActionCreators =\n    stackConfig.getCustomActionCreators || defaultActionCreators;\n\n  const initialRouteName = stackConfig.initialRouteName || routeNames[0];\n\n  const initialChildRouter = childRouters[initialRouteName];\n\n  function getInitialState(action) {\n    let route = {};\n    const childRouter = childRouters[action.routeName];\n\n    // This is a push-like action, and childRouter will be a router or null if we are responsible for this routeName\n    if (behavesLikePushAction(action) && childRouter !== undefined) {\n      let childState = {};\n      // The router is null for normal leaf routes\n      if (childRouter !== null) {\n        const childAction =\n          action.action || NavigationActions.init({ params: action.params });\n        childState = childRouter.getStateForAction(childAction);\n      }\n\n      return {\n        key: 'StackRouterRoot',\n        isTransitioning: false,\n        index: 0,\n        routes: [\n          {\n            params: action.params,\n            ...childState,\n            key: action.key || generateKey(),\n            routeName: action.routeName,\n          },\n        ],\n      };\n    }\n\n    if (initialChildRouter) {\n      route = initialChildRouter.getStateForAction(\n        NavigationActions.navigate({\n          routeName: initialRouteName,\n          params: initialRouteParams,\n        })\n      );\n    }\n    const params = (routeConfigs[initialRouteName].params ||\n      route.params ||\n      action.params ||\n      initialRouteParams) && {\n      ...(routeConfigs[initialRouteName].params || {}),\n      ...(route.params || {}),\n      ...(action.params || {}),\n      ...(initialRouteParams || {}),\n    };\n    const { initialRouteKey } = stackConfig;\n    route = {\n      ...route,\n      ...(params ? { params } : {}),\n      routeName: initialRouteName,\n      key: action.key || (initialRouteKey || generateKey()),\n    };\n    return {\n      key: 'StackRouterRoot',\n      isTransitioning: false,\n      index: 0,\n      routes: [route],\n    };\n  }\n\n  function getParamsForRouteAndAction(routeName, action) {\n    let routeConfig = routeConfigs[routeName];\n    if (routeConfig && routeConfig.params) {\n      return { ...routeConfig.params, ...action.params };\n    } else {\n      return action.params;\n    }\n  }\n\n  const {\n    getPathAndParamsForRoute,\n    getActionForPathAndParams,\n  } = createPathParser(childRouters, routeConfigs, stackConfig);\n\n  return {\n    childRouters,\n\n    getComponentForState(state) {\n      const activeChildRoute = state.routes[state.index];\n      const { routeName } = activeChildRoute;\n      if (childRouters[routeName]) {\n        return childRouters[routeName].getComponentForState(activeChildRoute);\n      }\n      return getScreenForRouteName(routeConfigs, routeName);\n    },\n\n    getComponentForRouteName(routeName) {\n      return getScreenForRouteName(routeConfigs, routeName);\n    },\n\n    getActionCreators(route, navStateKey) {\n      return {\n        ...getCustomActionCreators(route, navStateKey),\n        pop: (n, params) =>\n          StackActions.pop({\n            n,\n            ...params,\n          }),\n        popToTop: params => StackActions.popToTop(params),\n        push: (routeName, params, action) =>\n          StackActions.push({\n            routeName,\n            params,\n            action,\n          }),\n        replace: (replaceWith, params, action, newKey) => {\n          if (typeof replaceWith === 'string') {\n            return StackActions.replace({\n              routeName: replaceWith,\n              params,\n              action,\n              key: route.key,\n              newKey,\n            });\n          }\n          invariant(\n            typeof replaceWith === 'object',\n            'Must replaceWith an object or a string'\n          );\n          invariant(\n            params == null,\n            'Params must not be provided to .replace() when specifying an object'\n          );\n          invariant(\n            action == null,\n            'Child action must not be provided to .replace() when specifying an object'\n          );\n          invariant(\n            newKey == null,\n            'Child action must not be provided to .replace() when specifying an object'\n          );\n          return StackActions.replace(replaceWith);\n        },\n        reset: (actions, index) =>\n          StackActions.reset({\n            actions,\n            index: index == null ? actions.length - 1 : index,\n            key: navStateKey,\n          }),\n        dismiss: () =>\n          NavigationActions.back({\n            key: navStateKey,\n          }),\n      };\n    },\n\n    getStateForAction(action, state) {\n      // Set up the initial state if needed\n      if (!state) {\n        return getInitialState(action);\n      }\n\n      const activeChildRoute = state.routes[state.index];\n\n      if (\n        !isResetToRootStack(action) &&\n        action.type !== NavigationActions.NAVIGATE\n      ) {\n        // Let the active child router handle the action\n        const activeChildRouter = childRouters[activeChildRoute.routeName];\n        if (activeChildRouter) {\n          const route = activeChildRouter.getStateForAction(\n            action,\n            activeChildRoute\n          );\n          if (route !== null && route !== activeChildRoute) {\n            return StateUtils.replaceAt(\n              state,\n              activeChildRoute.key,\n              route,\n              // the following tells replaceAt to NOT change the index to this route for the setParam action, because people don't expect param-setting actions to switch the active route\n              action.type === NavigationActions.SET_PARAMS\n            );\n          }\n        }\n      } else if (action.type === NavigationActions.NAVIGATE) {\n        // Traverse routes from the top of the stack to the bottom, so the\n        // active route has the first opportunity, then the one before it, etc.\n\n        for (let childRoute of state.routes.slice().reverse()) {\n          let childRouter = childRouters[childRoute.routeName];\n          let childAction =\n            action.routeName === childRoute.routeName && action.action\n              ? action.action\n              : action;\n\n          if (childRouter) {\n            const nextRouteState = childRouter.getStateForAction(\n              childAction,\n              childRoute\n            );\n\n            if (nextRouteState === null || nextRouteState !== childRoute) {\n              const newState = StateUtils.replaceAndPrune(\n                state,\n                nextRouteState ? nextRouteState.key : childRoute.key,\n                nextRouteState ? nextRouteState : childRoute\n              );\n              return {\n                ...newState,\n                isTransitioning:\n                  state.index !== newState.index\n                    ? action.immediate !== true\n                    : state.isTransitioning,\n              };\n            }\n          }\n        }\n      }\n\n      // Handle push and navigate actions. This must happen after the focused\n      // child router has had a chance to handle the action.\n      if (\n        behavesLikePushAction(action) &&\n        childRouters[action.routeName] !== undefined // undefined means it's not a childRouter or a screen\n      ) {\n        const childRouter = childRouters[action.routeName];\n        let route;\n\n        invariant(\n          action.type !== StackActions.PUSH || action.key == null,\n          'StackRouter does not support key on the push action'\n        );\n\n        // Before pushing a new route we first try to find one in the existing route stack\n        // More information on this: https://github.com/react-navigation/rfcs/blob/master/text/0004-less-pushy-navigate.md\n        const lastRouteIndex = state.routes.findIndex(r => {\n          if (action.key) {\n            return r.key === action.key;\n          } else {\n            return r.routeName === action.routeName;\n          }\n        });\n\n        // An instance of this route exists already and we're dealing with a navigate action\n        if (action.type !== StackActions.PUSH && lastRouteIndex !== -1) {\n          // If index is unchanged and params are not being set, leave state identity intact\n          if (state.index === lastRouteIndex && !action.params) {\n            return null;\n          }\n\n          // Remove the now unused routes at the tail of the routes array\n          const routes = state.routes.slice(0, lastRouteIndex + 1);\n\n          // Apply params if provided, otherwise leave route identity intact\n          if (action.params) {\n            const route = state.routes[lastRouteIndex];\n            routes[lastRouteIndex] = {\n              ...route,\n              params: {\n                ...route.params,\n                ...action.params,\n              },\n            };\n          }\n          // Return state with new index. Change isTransitioning only if index has changed\n          return {\n            ...state,\n            isTransitioning:\n              state.index !== lastRouteIndex\n                ? action.immediate !== true\n                : state.isTransitioning,\n            index: lastRouteIndex,\n            routes,\n          };\n        }\n\n        if (childRouter) {\n          // Delegate to the child router with the given action, or init it\n          const childAction =\n            action.action ||\n            NavigationActions.init({\n              params: getParamsForRouteAndAction(action.routeName, action),\n            });\n          route = {\n            params: getParamsForRouteAndAction(action.routeName, action),\n            // note(brentvatne): does it make sense to wipe out the params\n            // here? or even to add params at all? need more info about what\n            // this solves\n            ...childRouter.getStateForAction(childAction),\n            routeName: action.routeName,\n            key: action.key || generateKey(),\n          };\n        } else {\n          // Create the route from scratch\n          route = {\n            params: getParamsForRouteAndAction(action.routeName, action),\n            routeName: action.routeName,\n            key: action.key || generateKey(),\n          };\n        }\n        return {\n          ...StateUtils.push(state, route),\n          isTransitioning: action.immediate !== true,\n        };\n      } else if (\n        action.type === StackActions.PUSH &&\n        childRouters[action.routeName] === undefined\n      ) {\n        // Return the state identity to bubble the action up\n        return state;\n      }\n\n      // Handle navigation to other child routers that are not yet pushed\n      if (behavesLikePushAction(action)) {\n        const childRouterNames = Object.keys(childRouters);\n        for (let i = 0; i < childRouterNames.length; i++) {\n          const childRouterName = childRouterNames[i];\n          const childRouter = childRouters[childRouterName];\n          if (childRouter) {\n            // For each child router, start with a blank state\n            const initChildRoute = childRouter.getStateForAction(\n              NavigationActions.init()\n            );\n            // Then check to see if the router handles our navigate action\n            const navigatedChildRoute = childRouter.getStateForAction(\n              action,\n              initChildRoute\n            );\n            let routeToPush = null;\n            if (navigatedChildRoute === null) {\n              // Push the route if the router has 'handled' the action and returned null\n              routeToPush = initChildRoute;\n            } else if (navigatedChildRoute !== initChildRoute) {\n              // Push the route if the state has changed in response to this navigation\n              routeToPush = navigatedChildRoute;\n            }\n            if (routeToPush) {\n              const route = {\n                ...routeToPush,\n                routeName: childRouterName,\n                key: action.key || generateKey(),\n              };\n              return {\n                ...StateUtils.push(state, route),\n                isTransitioning: action.immediate !== true,\n              };\n            }\n          }\n        }\n      }\n\n      // Handle pop-to-top behavior. Make sure this happens after children have had a chance to handle the action, so that the inner stack pops to top first.\n      if (action.type === StackActions.POP_TO_TOP) {\n        // Refuse to handle pop to top if a key is given that doesn't correspond\n        // to this router\n        if (action.key && state.key !== action.key) {\n          return state;\n        }\n\n        // If we're already at the top, then we return the state with a new\n        // identity so that the action is handled by this router.\n        if (state.index > 0) {\n          return {\n            ...state,\n            isTransitioning: action.immediate !== true,\n            index: 0,\n            routes: [state.routes[0]],\n          };\n        }\n        return state;\n      }\n\n      // Handle replace action\n      if (action.type === StackActions.REPLACE) {\n        let routeIndex;\n\n        // If the key param is undefined, set the index to the last route in the stack\n        if (action.key === undefined && state.routes.length) {\n          routeIndex = state.routes.length - 1;\n        } else {\n          routeIndex = state.routes.findIndex(r => r.key === action.key);\n        }\n\n        // Only replace if the key matches one of our routes\n        if (routeIndex !== -1) {\n          const childRouter = childRouters[action.routeName];\n          let childState = {};\n          if (childRouter) {\n            const childAction =\n              action.action ||\n              NavigationActions.init({\n                params: getParamsForRouteAndAction(action.routeName, action),\n              });\n            childState = childRouter.getStateForAction(childAction);\n          }\n          const routes = [...state.routes];\n          routes[routeIndex] = {\n            params: getParamsForRouteAndAction(action.routeName, action),\n            // merge the child state in this order to allow params override\n            ...childState,\n            routeName: action.routeName,\n            key: action.newKey || generateKey(),\n          };\n          return { ...state, routes };\n        }\n      }\n\n      // Update transitioning state\n      if (\n        action.type === StackActions.COMPLETE_TRANSITION &&\n        (action.key == null || action.key === state.key) &&\n        action.toChildKey === state.routes[state.index].key &&\n        state.isTransitioning\n      ) {\n        return {\n          ...state,\n          isTransitioning: false,\n        };\n      }\n\n      if (action.type === NavigationActions.SET_PARAMS) {\n        const key = action.key;\n        const lastRoute = state.routes.find(route => route.key === key);\n        if (lastRoute) {\n          const params = {\n            ...lastRoute.params,\n            ...action.params,\n          };\n          const routes = [...state.routes];\n          routes[state.routes.indexOf(lastRoute)] = {\n            ...lastRoute,\n            params,\n          };\n          return {\n            ...state,\n            routes,\n          };\n        }\n      }\n\n      if (action.type === StackActions.RESET) {\n        // Only handle reset actions that are unspecified or match this state key\n        if (action.key != null && action.key != state.key) {\n          // Deliberately use != instead of !== so we can match null with\n          // undefined on either the state or the action\n          return state;\n        }\n        const newStackActions = action.actions;\n\n        return {\n          ...state,\n          routes: newStackActions.map(newStackAction => {\n            const router = childRouters[newStackAction.routeName];\n\n            let childState = {};\n\n            if (router) {\n              const childAction =\n                newStackAction.action ||\n                NavigationActions.init({\n                  params: getParamsForRouteAndAction(\n                    newStackAction.routeName,\n                    newStackAction\n                  ),\n                });\n\n              childState = router.getStateForAction(childAction);\n            }\n\n            return {\n              params: getParamsForRouteAndAction(\n                newStackAction.routeName,\n                newStackAction\n              ),\n              ...childState,\n              routeName: newStackAction.routeName,\n              key: newStackAction.key || generateKey(),\n            };\n          }),\n          index: action.index,\n        };\n      }\n\n      if (\n        action.type === NavigationActions.BACK ||\n        action.type === StackActions.POP\n      ) {\n        const { key, n, immediate } = action;\n        let backRouteIndex = state.index;\n        if (action.type === StackActions.POP && n != null) {\n          // determine the index to go back *from*. In this case, n=1 means to go\n          // back from state.index, as if it were a normal \"BACK\" action\n          backRouteIndex = Math.max(1, state.index - n + 1);\n        } else if (key) {\n          const backRoute = state.routes.find(route => route.key === key);\n          backRouteIndex = state.routes.indexOf(backRoute);\n        }\n\n        if (backRouteIndex > 0) {\n          return {\n            ...state,\n            routes: state.routes.slice(0, backRouteIndex),\n            index: backRouteIndex - 1,\n            isTransitioning: immediate !== true,\n          };\n        }\n      }\n\n      // By this point in the router's state handling logic, we have handled the behavior of the active route, and handled any stack actions.\n      // If we haven't returned by now, we should allow non-active child routers to handle this action, and switch to that index if the child state (route) does change..\n\n      const keyIndex = action.key ? StateUtils.indexOf(state, action.key) : -1;\n\n      // Traverse routes from the top of the stack to the bottom, so the\n      // active route has the first opportunity, then the one before it, etc.\n      for (let childRoute of state.routes.slice().reverse()) {\n        if (childRoute.key === activeChildRoute.key) {\n          // skip over the active child because we let it attempt to handle the action earlier\n          continue;\n        }\n        // If a key is provided and in routes state then let's use that\n        // knowledge to skip extra getStateForAction calls on other child\n        // routers\n        if (keyIndex >= 0 && childRoute.key !== action.key) {\n          continue;\n        }\n        let childRouter = childRouters[childRoute.routeName];\n        if (childRouter) {\n          const route = childRouter.getStateForAction(action, childRoute);\n\n          if (route === null) {\n            return state;\n          } else if (route && route !== childRoute) {\n            return StateUtils.replaceAt(\n              state,\n              childRoute.key,\n              route,\n              // the following tells replaceAt to NOT change the index to this route for the setParam action or complete transition action,\n              // because people don't expect these actions to switch the active route\n              action.type === NavigationActions.SET_PARAMS ||\n                action.type === StackActions.COMPLETE_TRANSITION ||\n                action.type.includes('DRAWER')\n            );\n          }\n        }\n      }\n\n      return state;\n    },\n\n    getPathAndParamsForState(state) {\n      const route = state.routes[state.index];\n      return getPathAndParamsForRoute(route);\n    },\n\n    getActionForPathAndParams(path, params) {\n      return getActionForPathAndParams(path, params);\n    },\n\n    getScreenOptions: createConfigGetter(\n      routeConfigs,\n      stackConfig.defaultNavigationOptions\n    ),\n  };\n};\n"],"file":"StackRouter.js"}