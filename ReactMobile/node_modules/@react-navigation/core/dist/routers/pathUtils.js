function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/* eslint-disable import/no-commonjs */
import pathToRegexp, { compile } from 'path-to-regexp';
import NavigationActions from '../NavigationActions';
import invariant from '../utils/invariant';

var queryString = require('query-string');

export var getParamsFromPath = (inputParams, pathMatch, pathMatchKeys) => {
  var params = pathMatch.slice(1).reduce( // iterate over matched path params
  (paramsOut, matchResult, i) => {
    var key = pathMatchKeys[i];

    if (!key || key.asterisk) {
      return paramsOut;
    }

    var paramName = key.name;
    var decodedMatchResult;

    if (matchResult) {
      try {
        decodedMatchResult = decodeURIComponent(matchResult);
      } catch (e) {// ignore `URIError: malformed URI`
      }
    }

    paramsOut[paramName] = decodedMatchResult || matchResult;
    return paramsOut;
  }, _objectSpread({}, inputParams));
  return params;
};

var getRestOfPath = (pathMatch, pathMatchKeys) => {
  var rest = pathMatch[pathMatchKeys.findIndex(k => k.asterisk) + 1];
  return rest;
};

export var urlToPathAndParams = (url, uriPrefix) => {
  var searchMatch = url.match(/^(.*)\?(.*)$/);
  var params = searchMatch ? queryString.parse(searchMatch[2]) : {};
  var urlWithoutSearch = searchMatch ? searchMatch[1] : url;
  var delimiter = uriPrefix || '://';
  var path = urlWithoutSearch.split(delimiter)[1];

  if (path === undefined) {
    path = urlWithoutSearch;
  }

  if (path === '/') {
    path = '';
  }

  if (path[path.length - 1] === '/') {
    path = path.slice(0, -1);
  }

  return {
    path,
    params
  };
};
export var createPathParser = (childRouters, routeConfigs, {
  paths: pathConfigs = {},
  disableRouteNamePaths
}) => {
  var pathsByRouteNames = {};
  var paths = []; // Build pathsByRouteNames, which includes a regex to match paths for each route. Keep in mind, the regex will pass for the route and all child routes. The code that uses pathsByRouteNames will need to also verify that the child router produces an action, in the case of isPathMatchable false (a null path).

  Object.keys(childRouters).forEach(routeName => {
    var pathPattern; // First check for paths on the router, then check the route config

    if (pathConfigs[routeName] !== undefined) {
      pathPattern = pathConfigs[routeName];
    } else {
      pathPattern = routeConfigs[routeName].path;
    }

    if (pathPattern === undefined) {
      // If the user hasn't specified a path at all nor disableRouteNamePaths, then we assume the routeName is an appropriate path
      pathPattern = disableRouteNamePaths ? null : routeName;
    }

    invariant(pathPattern === null || typeof pathPattern === 'string', `Route path for ${routeName} must be specified as a string, or null.`); // the path may be specified as null, which is similar to empty string because it allows child routers to handle the action, but it will not match empty paths

    var isPathMatchable = pathPattern !== null; // pathPattern is a string with inline params, such as people/:id/*foo

    var exactReKeys = [];
    var exactRe = isPathMatchable ? pathToRegexp(pathPattern, exactReKeys) : null;
    var extendedPathReKeys = [];
    var isWildcard = pathPattern === '' || !isPathMatchable;
    var extendedPathRe = pathToRegexp(isWildcard ? '*' : `${pathPattern}/*`, extendedPathReKeys);
    pathsByRouteNames[routeName] = {
      exactRe,
      exactReKeys,
      extendedPathRe,
      extendedPathReKeys,
      isWildcard,
      toPath: pathPattern === null ? () => '' : compile(pathPattern)
    };
  });
  paths = Object.entries(pathsByRouteNames);

  var getActionForPathAndParams = (pathToResolve = '', inputParams = {}) => {
    // Attempt to match `pathToResolve` with a route in this router's routeConfigs, deferring to child routers
    for (var [routeName, path] of paths) {
      var {
        exactRe,
        exactReKeys,
        extendedPathRe,
        extendedPathReKeys
      } = path;
      var childRouter = childRouters[routeName];
      var exactMatch = exactRe && exactRe.exec(pathToResolve);

      if (exactMatch && exactMatch.length) {
        var extendedMatch = extendedPathRe && extendedPathRe.exec(pathToResolve);
        var childAction = null;

        if (extendedMatch && childRouter) {
          var restOfPath = getRestOfPath(extendedMatch, extendedPathReKeys);
          childAction = childRouter.getActionForPathAndParams(restOfPath, inputParams);
        }

        return NavigationActions.navigate({
          routeName,
          params: getParamsFromPath(inputParams, exactMatch, exactReKeys),
          action: childAction
        });
      }
    }

    for (var [_routeName, _path] of paths) {
      var {
        extendedPathRe: _extendedPathRe,
        extendedPathReKeys: _extendedPathReKeys
      } = _path;
      var _childRouter = childRouters[_routeName];

      var _extendedMatch = _extendedPathRe && _extendedPathRe.exec(pathToResolve);

      if (_extendedMatch && _extendedMatch.length) {
        var _restOfPath = getRestOfPath(_extendedMatch, _extendedPathReKeys);

        var _childAction = null;

        if (_childRouter) {
          _childAction = _childRouter.getActionForPathAndParams(_restOfPath, inputParams);
        }

        if (!_childAction) {
          continue;
        }

        return NavigationActions.navigate({
          routeName: _routeName,
          params: getParamsFromPath(inputParams, _extendedMatch, _extendedPathReKeys),
          action: _childAction
        });
      }
    }

    return null;
  };

  var getPathAndParamsForRoute = route => {
    var {
      routeName,
      params
    } = route;
    var childRouter = childRouters[routeName];
    var {
      toPath,
      exactReKeys
    } = pathsByRouteNames[routeName];
    var subPath = toPath(params);
    var nonPathParams = {};

    if (params) {
      Object.keys(params).filter(paramName => !exactReKeys.find(k => k.name === paramName)).forEach(paramName => {
        nonPathParams[paramName] = params[paramName];
      });
    }

    if (childRouter) {
      // If it has a router it's a navigator.
      // If it doesn't have router it's an ordinary React component.
      var child = childRouter.getPathAndParamsForState(route);
      return {
        path: subPath ? `${subPath}/${child.path}` : child.path,
        params: child.params ? _objectSpread({}, nonPathParams, child.params) : nonPathParams
      };
    }

    return {
      path: subPath,
      params: nonPathParams
    };
  };

  return {
    getActionForPathAndParams,
    getPathAndParamsForRoute
  };
};
//# sourceMappingURL=pathUtils.js.map